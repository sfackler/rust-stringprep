extern crate regex;

use regex::Regex;

use std::fs::File;
use std::io::prelude::*;
use std::io::BufWriter;

// Generate character mapping tables directly from the specification.
fn main() {
    let out_file = File::create("../src/rfc3454.rs").unwrap();
    let mut writer = BufWriter::new(out_file);

    write!(writer, "// AUTOGENERATED CODE - DO NOT EDIT\n\n").unwrap();

    lookup_table("A.1", &mut writer);
    mapping_table("B.2", &mut writer);
}

fn lookup_table<W: Write>(table: &str, writer: &mut W) {
    write!(
        writer,
        "pub const {}: &'static [(char, char)] = &[\n",
        table.replace(".", "_")
    ).unwrap();

    let regex = Regex::new("^([0-9A-F]+)(?:-([0-9A-F]+))?$").unwrap();
    table_lines(table, |line| {
        let captures = regex.captures(line).unwrap();
        let start = captures.get(1).unwrap().as_str();
        let end = captures.get(2).map_or(start, |c| c.as_str());
        write!(writer, "    ('\\u{{{}}}', '\\u{{{}}}'),\n", start, end).unwrap();
    });

    write!(writer, "];\n\n").unwrap();
}

fn mapping_table<W: Write>(table: &str, writer: &mut W) {
    write!(
        writer,
        "pub const {}: &'static [(char, &'static str)] = &[\n",
        table.replace(".", "_"),
    ).unwrap();

    let regex = Regex::new(
        "^([0-9A-F]+); ([0-9A-F]+)(?: ([0-9A-F]+))?(?: ([0-9A-F]+))?(?: ([0-9A-F]+))?;",
    ).unwrap();
    table_lines(table, |line| {
        let captures = regex.captures(line).unwrap();
        let mut it = captures.iter().filter_map(|i| i);
        it.next(); // skip whole match

        let input = it.next().unwrap().as_str();
        write!(writer, "    ('\\u{{{}}}', \"", input).unwrap();

        for output in it {
            write!(writer, "\\u{{{}}}", output.as_str()).unwrap();
        }

        write!(writer, "\"),\n").unwrap();
    });

    write!(writer, "];\n\n").unwrap();
}

fn table_lines<F>(table: &str, mut f: F)
where
    F: FnMut(&str),
{
    let mut lines = include_str!("rfc3454.txt").split('\n');

    // fast forward to the start of the table
    lines.find(|line| line.contains("Start Table") && line.contains(table));

    for line in lines {
        let line = line.trim();
        if line.contains("End Table") {
            break;
        }

        // Skip page headers/footers
        if line.is_empty() || line.contains("Hoffman & Blanchet") || line.contains("RFC 3454") {
            continue;
        }

        f(line);
    }
}
